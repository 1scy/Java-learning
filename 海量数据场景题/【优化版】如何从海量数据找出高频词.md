本期是【**大厂面试**】系列文章的第**34**期

回复【**手册**】获取大彬精心整理的**大厂面试手册**。

## 面试开始

旁白：通过微信聊天方式模拟现场面试，题目出自腾讯PCG一面

**面试官**：**上回考了你一道场景题，还记得不？**

**面试官**：**题目是这样的，一个1G大小的文件，文件里每一行是一个词，每个词的大小不超过16byte，要求返回出现频率最高的100个词**

**面试官**：**内存大小限制是10M**

**面试官**：**当时你给的解法有问题啊，还好我回去查了下，不然就给蒙混过关了。。**

**面试官**：**你用的是分治的思想，进行哈希取余，放进小文件。**

**面试官**：**但是在极端情况，比如都是同一个词或者某一个词超过10m，小文件会超过10m内存限制啊**

大彬：是的哦，上次的解法不严谨，今天给你介绍另一种解法：

**第一步**，对大文件的单词进行排序，排序之后，相同的单词会紧挨着

排序的步骤如下：

1.1 将文件按照顺序切分成大小不超过2m的小文件，总共500个小文件

1.2 使用10m内存**分别**对500个小文件中的单词进行**排序**

1.3 使用一个大小为500大小的堆，对500个小文件进行**多路排序**，结果写到一个大文件中

其中1.3步骤中，对500个小文件进行多路排序的思路如下：

- 初始化一个最小堆，大小就是小文件的个数500。堆中的每个节点存放每个有序小文件对应的输入流。
- 按照每个有序文件中的下一行数据对所有文件输入流进行排序，单词小的输入文件流放在堆顶。
- 拿出堆顶的输入流，并其下一行数据写入到最终排序的文件中，如果拿出来的输入流中还有数据的话，那么将这个输入流再一次添加到堆中。否则说明该文件输入流中没有数据了，那么可以关闭这个流。
- 循环这个过程，直到所有文件输入流都没有数据为止。

**第二步**：

2.1 初始化一个100个节点的**小顶堆**，用于保存100个出现频率最多的单词

2.2 遍历整个文件，一个单词一个单词的从文件中取出来，并计数

2.3 等到遍历的单词和上一个单词不同的话，那么上一个单词及其频率如果大于堆顶的词的频率，那么放在堆中，否则不放

最终，小顶堆中就是出现频率前100的单词了。

可以看出，这种解法相对之前的解法，更为严谨，就算整个文件都是同一个词，此解法同样有效。

**面试官**：行吧，今天面试就到这里吧



## 点关注，不迷路

大彬，**非科班出身，自学Java**，校招斩获京东、携程、华为等offer。作为一名转码选手，深感这一路的不易。

希望我的分享能帮助到更多的小伙伴，**我踩过的坑你们不要再踩**。想与大彬交流的话，可以到公众号后台获取大彬的微信~

后台回复『 **笔记**』即可领取大彬斩获大厂offer的**面试笔记**。

![](https://raw.githubusercontent.com/Tyson0314/img/master/公众号.jpg)

