<a id="b树"></a>

## B+树

[Mysql B+索引](https://blog.csdn.net/chybin500/article/details/103057140) | [索引演化](https://juejin.im/post/5b08fcc86fb9a07a9b3666ac#heading-4) | [为什么MySQL数据库索引选择使用B+树？](https://www.cnblogs.com/tiancai/p/9024351.html)

MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。

<a id="索引的作用"></a>

### 索引的作用

数据是存储在磁盘上的，操作系统读取磁盘的最小单位是块，如果没有索引，会加载所有的数据到内存，依次进行检索，加载的总数据会很多，磁盘IO多。

<a id="索引实例"></a>

### 索引实例

col1 是主键，col2和col3 是普通字段。

![image-20200520234137916](E:/project/java/learn/Java-learning/img/image-20200520234137916.png)

主索引 对应的 B+树 结构，每个节点对应磁盘的一页。

![image-20200520234200868](E:/project/java/learn/Java-learning/img/image-20200520234200868.png)

对col3 建立一个单列索引，对应的B+树结构（图中叶子节点少画了Col2）：

![image-20200520234231001](E:/project/java/learn/Java-learning/img/image-20200520234231001.png)

<a id="数据定位过程"></a>

### 数据定位过程

进行定位操作时，不再进行表扫描，而是进行索引扫描。非叶子节点都是索引块，叶子节点是索引和数据。

第一种场景：索引精确查找

```mysql
select * from user_info where id = 23 ;
```

将根节点索引块读到内存, 逐层向下查找, 读取叶子节点Page,通过二分查找找到记录或未命中。

![索引精确查找](https://user-gold-cdn.xitu.io/2018/5/26/1639b1b65e8e3aa7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第二种场景：索引范围查找

```msyql
select * from user_info where id >= 18 and id < 22 ;
```

读取根节点至内存, 确定索引定位条件id=18, 找到满足条件第一个叶节点, 顺序扫描所有结果, 直到终止条件满足id >=22。

![索引范围查找](https://user-gold-cdn.xitu.io/2018/5/26/1639b1b65e6f159a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第三种场景：全表扫描

```mysql
select * from user_info where name = 'abc' ;
```

直接读取叶节点头结点， 顺序扫描， 返回符合条件记录， 到最终节点结束。

![全表扫描](https://user-gold-cdn.xitu.io/2018/5/26/1639b1b67f61b3d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第四中场景：二级索引查找

```mysql
create table table_x(int id primary key, varchar(64) name , key sec_index(name) ) ;
select * from table_x where name = 'd' ;
```

通过二级索引查出对应主键（叶子节点是二级索引和主键，匹配的主键可能有多个），查主键索引得到数据， 二级索引可筛选掉大量无效记录，提高效率。

![二级索引查找](https://user-gold-cdn.xitu.io/2018/5/26/1639b1b6958ddd6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<a id="不用hash的原因"></a>

### 不用hash的原因

查询某条数据，自然是hash算法快，但是我们平常用的查询往往不是只查询单条数据，而是order by，group by，< >这种排序查询，遇到这种情况，hash就会退化成O(n)，而树因为它的有序性依然保持O(log(n))高效率。如果索引的值有重复的话，会发生hash碰撞，导致查询效率降低。

<a id="带有顺序访问指针的btree"></a>

### 带有顺序访问指针的B+Tree

一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。做这个优化的目的是为了提高区间访问的性能。比如要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

<a id="b树比b树更适合数据库索引"></a>

### B+树比B树更适合数据库索引

由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。

B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。

B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。



## 数据库特性（ACID）
对于几个SQL语句，要么全部执行成功，要么全部执行失败。比如银行转账就是事务的典型场景。
数据库事务的三个常用命令：Begin Transaction、Commit Transaction、RollBack Transaction。

①原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
②一致性是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
③隔离性，一个事务所做的修改在最终提交之前，对其他事务是不可见的。
④持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



## 数据库事务隔离级别
①脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
②不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
③幻读（虚读）是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就好像产生幻觉一样，这就是发生了幻读。

不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。
幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是某个数据整体。

MySQL数据库为我们提供的四种隔离级别：
① Serializable (串行化)：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
② Repeatable read (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
③ Read committed (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
④ Read uncommitted (读未提交)：所有事务都可以看到其他未提交事务的执行结果。

设置数据库的隔离级别一定要是在开启事务之前！
如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前连接的隔离级别

## 索引
索引是存储引擎用于提高数据库表的数据访问速度的一种数据结构（最常见的是B-Tree）。

特点：
避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页
可以提升查询语句的执行效率，但降低了新增、删除操作的速度，同时也会占用额外的存储空间。

### 索引分类
1. 唯一索引：索引列中的值必须是唯一的，但是允许为空值。
2. 主键索引：是一种特殊的唯一索引，不允许有空值。
3. 组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。
4. 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。
5. 空间索引：空间索引是对空间数据类型的字段建立的索引，空间索引必须使用MyISAM引擎

- 聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。聚簇索引的叶子节点存放的是数据本身。
- 非聚簇索引的索引顺序与数据的物理排列顺序无关。非聚簇索引的叶子节点存放的是数据的地址。

### 索引失效
1.如果条件中有or（要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引）
2.对于多列索引，不是使用的第一个索引列，则不会使用索引
3.like查询是以%开头
4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引
5.对索引字段判断是否为NULL时(is null 或is not null)
6.判断索引列是否不等于某个值时
7.对索引列进行运算。

### 聚簇索引

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点是索引节点，指向对应数据块的指针。MyISAM的是非聚簇索引，InnoDB 主键使用的是聚簇索引。

### UNIQUE 

PRIMARY KEY = UNIQUE KEY + NULL，UNIQUE 约束的列可以为空且仅要求列中的值除null之外不重复即可。
UNIQUE KEY的用途：唯一标识数据库表中的每条记录，主要是用来防止数据插入的时候重复的。
唯一键约束，可以在一个列上添加约束，也可以在多个列上添加唯一约束。

```sql
ALTER TABLE table_name
ADD CONSTRAINT constraint_name UNIQUE KEY(column_1,column_2,...);
```

<a id="二级索引"></a>

### 二级索引

聚簇索引和二级索引的非叶子节点都只存了索引列的值，聚簇索引叶子节点存有索引列和数据项，而二级索引的叶子节点存的是索引列和主键值。

<a id="最左匹配"></a>

### 最左匹配

[最左匹配](https://www.zhihu.com/search?type=content&q=%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D)

对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会对b进行比较排序）。

<a id="稠密索引"></a>

### 稠密索引

稠密索引：每个索引字段的值都对应一个索引项。

![image-20200614165432775](E:/project/java/learn/Java-learning/img/image-20200614165432775.png)

稀疏索引只包含了索引字段中一部分的值，通过这些值可以确定目标记录的范围，然后再到这个范围中顺序查找。

![image-20200614165333479](E:/project/java/learn/Java-learning/img/image-20200614165333479.png)

## 

## 乐观锁悲观锁

- 乐观锁假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查有没有其他事务修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观锁多用于数据争用不大、冲突较少的环境中。
- 悲观锁在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。悲观并发控制主要用于数据争用激烈的环境。

乐观锁的一种实现方式，CAS(比较并交换)。CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（E）和拟写入的新值(N)。如果内存位置V的值与预期原值E相匹配，那么处理器会自动将该位置值更新为新值N。否则不更新。最后会返回该位置的值。（冲突检查+数据更新）

synchronized 是悲观锁。

## 存储引擎
### InnoDB
InnoDB是mysql默认的事务型存储引擎，使用最广泛，基于聚簇索引建立的，InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。InnoDB引入了行级锁和外键约束。缺点是占用的数据空间相对较大。
适用场景：一般来说，如果需要事务支持，并且有较高的并发读写频率，InnoDB是不错的选择。

### MyISAM
MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键，不过它访问速度快，如果对事务完整性没有要求可以使用这个引擎来创建表。

### MEMORY
MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。虽然在内存中存储表数据确实会提供很高的性能，但是一旦系统奔溃的话，数据都会丢失。

## sql优化
 [sql优化](https://blog.csdn.net/jie_liang/article/details/77340905)
 1. 在where和order by涉及的字段加索引，避免全表扫描。
 2. 避免在where子句使用大于小于不等于的操作符。
 3. 不要在where子句中对字段进行null值判断。
 4. 建有索引的字段不要使用函数进行操作。
 5. 搜索字符型字段，避免使用like和通配符，可以考虑全文检索。
 6. 用exists代替in
 7. 索引不是越多越好，会降低insert和update的效率。
 8. 
 show index from table_name;
 explain select * from student where ID = 1000;

## Mysql数据库优化
1. 选取合适的字段属性(能用mediumint就不用bigint)，尽量将字段设置为NOT NULL(查询的时候不会去比较NULL值)，某些文本字段可以用ENUM代替(像性别，ENUM类型会被当做数值型数据处理，处理速度比文本类型快)。
2. 使用连接join代替子查询。join不需要在内存中创建临时表。
3. 使用union代替创建临时表。使用union查询完，会自动删除临时表。

## mysql的锁
MySQL各存储引擎使用了三种类型的锁定机制：表级锁定，行级锁定和页级锁定。
- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

表级锁
每种mysql存储引擎都可以实现自己的锁策略和锁粒度。
MyISAM和MEMORY存储引擎采用的是表级锁，读取时会对需要读到的所有表加读锁，写入时则对表加写锁。
对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作。

行级锁
InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。
行级锁类型：共享锁(S锁)/排他锁(X锁)/意向共享锁(IS)/意向排他锁(IX)
事务对表加S锁，其他事务可以该表加S锁，不能加X锁。
事务对表加X锁，其他事务不能对该表加任何锁。
为了方便检测表级锁和行级锁之间的冲突,就引入了意向锁。
意向锁是表级锁。当事务A对表t的某些行修改，需要对t加上意向排它锁，在A事务完成之前，如果B事务需要对表t加表锁，此时表t的意向排它锁就能告诉B需要等待，而不需要判断表中的每一行是否已经被行锁锁住。
意向锁之间不会冲突, 因为意向锁仅仅代表要对某行记录进行操作。在加行锁时，会判断是否冲突。
意向锁是InnoDB自动加的，不需用户干预。

间隙锁(Next-Key锁)
当我们用范围条件查询数据时，对于键值在条件范围内但不存在的记录(即间隙)，innoDB会对这个间隙加锁，以防止幻影行的插入，避免幻读的出现。

## 分库分表
垂直划分数据库是根据业务进行划分，例如将shop库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能，但这种方式并没有解决高数据量带来的性能损耗。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如用户表可根据业务分成基本信息表和详细信息表等。
优点：拆分后业务清晰，达到专库专用；便于维护
缺点：不解决数据量大带来的性能损耗，读写压力依旧很大；不同的业务无法跨库关联（join），只能通过业务来关联

水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。
优点：单库（表）的数据量得以减少，提高性能；提高了系统的稳定性和负载能力；切分出的表结构相同，程序改动较少
缺点：数据分片在扩容时需要迁移；维护量增大；无法跨库关联


## 数据库范式
- 第一范式1NF：数据表中的每一列，必须是不可拆分的最小单元，也就是确保每一列的原子性。
userInfo: '山东省烟台市 1318162008' 依照第一范式必须拆分成 userInfo: '山东省烟台市  'userTel: '1318162008'两个字段

- 第二范式2NF：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，主键为(学号, 课程名称)，因为存在如下决定关系：(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)
其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录），插入异常（插入一门新课，因为没有学号，无法保存新课记录）等。
可以拆分成三个表：学生：Student(学号, 姓名, 年龄)；课程：Course(课程名称, 学分)；选课关系：SelectCourse(学号, 课程名称, 成绩)。

- 第三范式3NF：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
假定学生关系表为Student(学号, 姓名, 年龄, 学院id, 学院地点, 学院电话)，主键为"学号"，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。
把学生关系表分为如下两个表：学生：(学号, 姓名, 年龄, 学院id)；学院：(学院,id 地点, 电话)。

2NF和3NF区别
2NF依据非主键列是否完全依赖于主键，还是依赖于主键的一部分
3NF依据非主键列是直接依赖于主键，还是直接依赖于非主键

## join
natural join按照**相同列名**进行连接，会去除重复的列名，不能使用using指定join哪个column
join 默认是 inner join(table1 inner join table2 on ...)
join...using(column)按指定的属性做等值连接
join...on tableA.column1 = tableB.column2 指定条件

内联接（Inner Join）：匹配2张表中相关联的记录。
左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。
右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。
在判定左表和右表时，要根据表名出现在Outer Join的左右位置关系。

等值连接有两种方式，一种是where子句（隐性连接），一种是inner join关键字（显性连接），两者执行过程不同：
- 隐性连接会对所有的表做笛卡尔积，最终通过where条件过滤；
- 显性连接在每一次表连接时进行on条件过滤，筛选后的结果集再跟下一个表做笛卡尔积，以此循环。

显性连接效率更高。



## MVCC

MVCC(`Multiversion concurrency control`) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制。在读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，在新版本上的数据进行操作，读操作则依旧访问旧版本的数据。