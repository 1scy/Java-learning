<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [滑动窗口](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3)
- [拥塞控制](#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
  - [慢开始](#%E6%85%A2%E5%BC%80%E5%A7%8B)
  - [拥塞避免](#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D)
  - [快重传](#%E5%BF%AB%E9%87%8D%E4%BC%A0)
  - [快恢复](#%E5%BF%AB%E6%81%A2%E5%A4%8D)
- [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
- [四次挥手](#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
- [TCP 和 UDP](#tcp-%E5%92%8C-udp)
  - [TCP的特点](#tcp%E7%9A%84%E7%89%B9%E7%82%B9)
  - [区别](#%E5%8C%BA%E5%88%AB)
  - [TCP对应的协议和UDP对应的协议](#tcp%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8Cudp%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE)
  - [TCP首部](#tcp%E9%A6%96%E9%83%A8)
  - [UDP首部](#udp%E9%A6%96%E9%83%A8)
- [session cookie](#session-cookie)
  - [区别](#%E5%8C%BA%E5%88%AB-1)
- [http](#http)
  - [post和get](#post%E5%92%8Cget)
  - [http/https](#httphttps)
- [DNS解析](#dns%E8%A7%A3%E6%9E%90)
- [浏览器中输入URL到返回页面的全过程](#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%88%B0%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B)
- [停止等待协议&超时重传](#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0)
- [IP首部](#ip%E9%A6%96%E9%83%A8)
- [协议层](#%E5%8D%8F%E8%AE%AE%E5%B1%82)
- [ARP协议的工作原理](#arp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
- [子网划分](#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86)
- [NAT](#nat)
- [url](#url)
- [对称加密](#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86)
- [HTTPS](#https)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 滑动窗口

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

![滑动窗口](https://img2018.cnblogs.com/blog/1252910/201908/1252910-20190823173235953-969655958.png)

[计算机网络](https://github.com/jolesen/BOOKS)



## 拥塞控制

防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。

![](../img/拥塞控制.jpg)

### 慢开始

把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。

  当 cwnd < ssthresh 时，使用慢开始算法。

  当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

  当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

### 拥塞避免

让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

### 快重传

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。

快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

### 快恢复

当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

 在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。

[拥塞控制](https://www.cnblogs.com/losbyday/p/5847041.html)



## 三次握手

1. 第一次握手：A的TCP客户进程首先创建传输控制块TCB，然后向B发出连接请求报文段（首部的同步位SYN=1，初始序号seq=x），SYN=1的报文段不能携带数据但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。
2. 第二次握手：B收到连接请求报文段后，如同意建立连接，则向A发送确认（确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），B进入SYN-RCVD（同步收到）状态；
3. 第三次握手：A收到B的确认后，要向B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED。

![三次握手](https://img2018.cnblogs.com/blog/1252910/201909/1252910-20190912193729969-2125931519.png)

为什么A还要发送一次确认呢？可以二次握手吗？

答：主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。


## 四次挥手

假设Client端发起中断连接请求，也就是发送FIN终止报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。Server端发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"Client端我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭。这时Client端也可以关闭连接了。

![四次挥手](https://img2018.cnblogs.com/blog/1252910/201908/1252910-20190823193334395-1767472912.png)

1. A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。
2. B收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。
3. A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。
4. B发送完数据，就会发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。
5. A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最长报文段寿命）后，A才进入CLOSED状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。

为什么A在TIME-WAIT状态必须等待2MSL的时间？

1）保证A发送的最后一个ACK报文段能够到达B。2）防止“已失效的连接请求报文段”出现在本连接中。

1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。
2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。



## TCP 和 UDP

TCP 传输控制协议；UDP 用户数据报协议

### TCP的特点

- TCP是面向连接的运输层协议
- 每一条TCP连接只能有两个端点(一对一)
- TCP提供可靠交付的服务
- TCP提供全双工通信
- 面向字节流

- TCP可靠传输、流量控制和拥塞控制的实现
TCP的可靠性如何保证：对于收到的请求，给出确认响应
流量控制:让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口实现流量控制。
拥塞控制:防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
TCP可靠传输是因为有: 数据报校验, 失序数据重排序, 丢弃重复数据,应答机制,超时重发,流量控制等原因

### 区别
TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接
TCP提供可靠的服务；UDP不保证可靠交付
TCP面向字节流，把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信
TCP首部开销20字节；UDP的首部开销小，只有8个字节
![在这里插入图片描述](https://img-blog.csdn.net/20180924195157174?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### TCP对应的协议和UDP对应的协议

计算机网络p206

TCP对应的协议：
（1）FTP：定义了文件传输协议，使用21端口。
（2）Telnet：用于远程登陆的端口。
（3）SMTP：定义了简单邮件传送协议。25
（4）POP3：它是和SMTP对应，POP3用于接收邮件。110端口。
（5）HTTP协议：是从万维网服务器传输超文本到本地浏览器的传送协议。80

UDP对应的协议：
（1）DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
（2）SNMP：简单网络管理协议，使用161号端口
（3）TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。
（4）RIP(路由信息协议)
（5）DHCP（动态主机配置协议）


### TCP首部

![在这里插入图片描述](https://img-blog.csdn.net/20180924195341168)

### UDP首部

![在这里插入图片描述](https://img-blog.csdn.net/20180924195345900?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



## session cookie

由于HTTP协议是无状态的协议，所以当服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。
会话机制：Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。

Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体中的，而是存放于HTTP响应头；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。 自此，客户端再向服务器发送请求的时候，都会把相应的Cookie存放在HTTP请求头再次发回至服务器。服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。网站的登录界面中“请记住我”这样的选项，就是通过Cookie实现的。
![在这里插入图片描述](https://img-blog.csdn.net/20180924195237286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

cookie工作流程：
1. servlet创建cookie，保存少量数据，发送给浏览器。
2. 浏览器获得服务器发送的cookie数据，将自动的保存到浏览器端。
3. 下次访问时，浏览器将自动携带cookie数据发送给服务器。

session原理：首先浏览器请求服务器访问web站点时，服务器首先会检查这个客户端请求是否已经包含了一个session标识、称为SESSIONID，如果已经包含了一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，如果客户端请求不包含session id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的sessionid存放到cookie中，这个sessionid将在本次响应中返回到客户端保存，这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session。以此来达到共享数据的目的。 这里需要注意的是，session不会随着浏览器的关闭而死亡，而是等待超时时间。
session的工作原理就是依靠cookie来做支撑，第一次使用request.getSession()时session被创建
![在这里插入图片描述](https://img-blog.csdn.net/20180924195247106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 区别

Session是服务器端记录用户信息的一种机制，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

cookie保存了用户是谁，session保存了用户干了些什么。

cookie保存用户名和密码，客户端携带这些信息访问服务器，服务器端对用户名密码验证，验证通过生成session id，放到响应头set-cookie字段，发给客户端，以后客户端访问服务器都会带上这个session id。



## http

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。
HTTP是TCP/IP模型中的应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。
HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。

主要特点
1.简单快速：HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
2.灵活：HTTP允许传输任意类型的数据。传输的类型由Content-Type加以标记。
3.HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1支持使用持续连接：一个连接可以处理多个请求，不必为每个请求创建一个新的连接，采用这种方式可以节省传输时间。
4.无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，不会造成不必要连接占用，缺点在于如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。（session）
5.支持C/S模式。

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接

http协议（由请求跟响应构成）
请求消息request：由请求行（request line）、请求头部（header）、空行和请求体四个部分组成。
请求行：请求方法，访问的资源URL，使用的HTTP版本；GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。
请求头包含一些属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。（cookie,host,支持的语言,支持的编码,浏览器版本）
请求体：用户的请求数据如用户名，密码等
![在这里插入图片描述](https://img-blog.csdn.net/20180924195305583?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

响应消息response
HTTP响应也由四个部分组成，分别是：状态行、响应头、空行和响应体。
状态行：协议版本，状态码及状态描述
响应头：内容编码，长度，类型，Last-Modified，Set-Cookie，Cache-Control，Location，Expires
![在这里插入图片描述](https://img-blog.csdn.net/20180924195318593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

http状态码
![在这里插入图片描述](https://img-blog.csdn.net/20180924195323664?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
https://www.cnblogs.com/zt123123/p/8327706.html

### post和get
post和get请求的区别
GET请求参数通过URL传递，POST的参数放在请求体中。
GET请求的参数是有长度限制的，而POST没有。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET和POST是HTTP协议中的两种发送请求的方法。GET/POST请求都是TCP连接。
GET产生一个TCP数据包；POST产生两个TCP数据包。（对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体）
GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

### HTTPS

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
HTTPS：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。

HTTPS传输过程：

1. 客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；

2. 互相传递三个随机数，之后通过这随机数来生成一个对称密钥；

3. 互相发送使用对称秘钥加密的握手完成信息，确认密钥，然后握手结束；

4. 数据通讯开始，都使用同一个对称密钥来加解密；

   ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9KZExrRUk5c1pmZXIxV1NQWWljN0trWWJpYm1wTkYwVnVPWTdsbU1qb0U4SVZPejhpYzNBQUZFWkFFOGliUmVhSjc4dWxWMXU4TTdQU1pGMzJwWllNS0tZV0EvNjQw?x-oss-process=image/format,png)

[http/https](https://www.cnblogs.com/wqhwe/p/5407468.html)

### HTTPS和HTTP的区别
1、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
2、http和https用的端口不一样，前者是80，后者是443。
3、https协议需要到ca机构申请证书，一般免费证书较少，因而需要一定费用。



## DNS解析

1浏览器搜索自己的DNS缓存（维护一张域名与IP地址的对应表）
2若没有，则搜索操作系统中的DNS缓存和hosts文件
3若没有，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则通过递归或者迭代的查询方式依次向根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回IP地址给本地域名服务器
4本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来
5操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来
6至此，浏览器已经得到了域名对应的IP地址


## 浏览器中输入URL到返回页面的全过程
第一步，解析域名，找到主机IP
第二步，浏览器利用IP直接与网站主机通信。三次握手
第三步，浏览器向主机发起一个HTTP-GET报文请求。
第四步，服务器响应请求，发回网页内容。浏览器解析网页内容。
[浏览器中输入URL到返回页面的全过程](https://www.cnblogs.com/jiaosq/p/5841366.html)

## 停止等待协议&超时重传
停止等待协议能够在不可靠的传输网络上面实现可靠的通信。每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。分组需要编号。
超时重传是指：只要过了一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间长一些。这种自动重传方式常称为自动重传请求ARQ.


## IP首部
![在这里插入图片描述](https://img-blog.csdn.net/20180924195350449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 协议层
OSI是Open System Interconnect的缩写，意为开放式系统互联。
OSI分层（7层）:物理层、数据链路层、网络层、运输层、会话层、表示层、应用层
TCP/IP分层（4层）:网络接口层、网络层、运输层、应用层
五层协议（5层）:物理层、数据链路层、网络层、运输层、应用层
![在这里插入图片描述](https://img-blog.csdn.net/20180924195356897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## ARP协议的工作原理
ARP是解决同一个局域网上的主机和路由器ip和MAC地址的解析。
首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

## 子网划分
传统的两级ip地址空间利用率很低，一个A类网络可连接的主机数可超过1000万台，但实际连接的主机数并不多。所以需要对网络进行子网划分，通过子网掩码来区分网络。
三级ip地址：<网络号><子网号><主机号>

路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。

## NAT
NAT（Network Address Translation，网络地址转换）是将IP 数据包头中的IP 地址转换为另一个IP 地址的过程。在实际应用中，NAT 主要用于实现私有网络访问公共网络的功能。
DNAT Destination Network Address Translation 目的网络地址转换。
SNAT Source Network Address Translation 源网络地址转换。
[SNAT和DNAT](https://andyyoung01.github.io/2017/03/29/Linux%E7%BD%91%E7%BB%9C%E7%9A%84SNAT%E5%92%8CDNAT/)
[NAT](https://blog.csdn.net/lasoup/article/details/78289735)


## url
url：URI的子集。例如https://www.zhihu.com/question/21950864
uri：21950864



## 对称加密

对称加密：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。

非对称加密：它需要生成两个密钥：公钥(Public Key)和私钥(Private Key)。公钥顾名思义是公开的，任何人都可以获得，而私钥是私人保管的。我们提交代码到github的时候，就可以使用SSH key：在本地生成私钥和公钥，私钥放在本地`.ssh`目录中，公钥放在github网站上，这样每次提交代码，不用麻烦的输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。公钥负责加密，私钥负责解密；或者，私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。

对称加密和非对称加密需要搭配使用更主要的原因是：

1）对称加密：两边需要使用相同的密钥，需要使用一种安全的方式交换密钥，单纯使用对称加密，无法实现密钥交换。

2）非对称加密：只使用非对称加密是可以满足安全性要求的，但是由于非对称加密的计算耗时高于对称加密的2-3个数量级（相同安全加密级别），所以才先使用非对称交换密钥，之后再使用对称加密通信。


