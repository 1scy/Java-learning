## TCP 和 UDP

TCP 传输控制协议；UDP 用户数据报协议

### TCP的特点

- TCP是面向连接的运输层协议
- 每一条TCP连接只能有两个端点(一对一)
- TCP提供可靠交付的服务
- TCP提供全双工通信
- 面向字节流

- TCP可靠传输、流量控制和拥塞控制的实现
TCP的可靠性如何保证：对于收到的请求，给出确认响应
流量控制:让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口实现流量控制。
拥塞控制:防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
TCP可靠传输是因为有: 数据报校验, 失序数据重排序, 丢弃重复数据,应答机制,超时重发,流量控制等原因

### 区别
TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接
TCP提供可靠的服务；UDP不保证可靠交付
TCP面向字节流，把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信
TCP首部开销20字节；UDP的首部开销小，只有8个字节
![在这里插入图片描述](https://img-blog.csdn.net/20180924195157174?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


### 三次握手，四次挥手
[三次握手，四次挥手](https://www.cnblogs.com/Andya/p/7272462.html)

### TCP对应的协议和UDP对应的协议

计算机网络p206

TCP对应的协议：
（1）FTP：定义了文件传输协议，使用21端口。
（2）Telnet：用于远程登陆的端口。
（3）SMTP：定义了简单邮件传送协议。25
（4）POP3：它是和SMTP对应，POP3用于接收邮件。110端口。
（5）HTTP协议：是从万维网服务器传输超文本到本地浏览器的传送协议。80

UDP对应的协议：
（1）DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
（2）SNMP：简单网络管理协议，使用161号端口
（3）TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。
（4）RIP(路由信息协议)
（5）DHCP（动态主机配置协议）


### TCP首部

![在这里插入图片描述](https://img-blog.csdn.net/20180924195341168)

### UDP首部

![在这里插入图片描述](https://img-blog.csdn.net/20180924195345900?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



## 拥塞控制的四种算法

[拥塞控制](https://www.cnblogs.com/losbyday/p/5847041.html)



## session cookie

由于HTTP协议是无状态的协议，所以当服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.
会话机制：Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。
Session是服务器端记录用户信息的一种机制，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体中的，而是存放于HTTP响应头；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。 自此，客户端再向服务器发送请求的时候，都会把相应的Cookie存放在HTTP请求头再次发回至服务器。服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。网站的登录界面中“请记住我”这样的选项，就是通过Cookie实现的。
![在这里插入图片描述](https://img-blog.csdn.net/20180924195237286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

cookie工作流程：
1. servlet创建cookie，保存少量数据，发送给浏览器。
2. 浏览器获得服务器发送的cookie数据，将自动的保存到浏览器端。
3. 下次访问时，浏览器将自动携带cookie数据发送给服务器。

session原理：首先浏览器请求服务器访问web站点时，服务器首先会检查这个客户端请求是否已经包含了一个session标识、称为SESSIONID，如果已经包含了一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，如果客户端请求不包含session id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的sessionid存放到cookie中，这个sessionid将在本次响应中返回到客户端保存，这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session。以此来达到共享数据的目的。 这里需要注意的是，session不会随着浏览器的关闭而死亡，而是等待超时时间。
session的工作原理就是依靠cookie来做支撑，第一次使用request.getSession()时session被创建
![在这里插入图片描述](https://img-blog.csdn.net/20180924195247106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


## http
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。
HTTP是TCP/IP模型中的应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。
HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。

主要特点
1.简单快速：HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
2.灵活：HTTP允许传输任意类型的数据。传输的类型由Content-Type加以标记。
3.HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1支持使用持续连接：一个连接可以处理多个请求，不必为每个请求创建一个新的连接，采用这种方式可以节省传输时间。
4.无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，不会造成不必要连接占用，缺点在于如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。（session）
5.支持C/S模式。

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接

http协议（由请求跟响应构成）
请求消息request：由请求行（request line）、请求头部（header）、空行和请求体四个部分组成。
请求行：请求方法，访问的资源URL，使用的HTTP版本；
GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。
请求头包含一些属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。
 （cookie,host,支持的语言,支持的编码,浏览器版本）
请求体：用户的请求数据如用户名，密码等
![在这里插入图片描述](https://img-blog.csdn.net/20180924195305583?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

响应消息response
HTTP响应也由四个部分组成，分别是：状态行、响应头、空行和响应体。
状态行：报文协议及版本，状态码及状态描述
响应头：内容编码，长度，类型，Last-Modified，Set-Cookie，Cache-Control，Location，Expires
![在这里插入图片描述](https://img-blog.csdn.net/20180924195318593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

http状态码
![在这里插入图片描述](https://img-blog.csdn.net/20180924195323664?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
https://www.cnblogs.com/zt123123/p/8327706.html

### post和get
post和get请求的区别
GET请求参数通过URL传递，POST的参数放在请求体中。
GET请求的参数是有长度限制的，而POST没有。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET和POST是HTTP协议中的两种发送请求的方法。GET/POST请求都是TCP连接。
GET产生一个TCP数据包；POST产生两个TCP数据包。（对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体）
GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

### http/https
HTTP协议以明文方式发送内容，不提供任何方式的数据加密，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
HTTPS：是以安全为目标的HTTP通道，也就是是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

HTTPS和HTTP的区别主要如下：
1、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
2、http和https用的端口不一样，前者是80，后者是443。
3、https协议需要到ca机构申请证书，一般免费证书较少，因而需要一定费用。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议

加密过程
①服务器把自己的公钥登录至数字证书认证机构。
②数字证书机构把自己的私有密钥向服务器的公开密码部署数字签名并颁发公钥证书。
③客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名。以确认服务器公钥的真实性。
④使用服务器的公开密钥对报文加密后发送。
⑤服务器用私有密钥对报文解密。

[http/https](https://www.cnblogs.com/wqhwe/p/5407468.html)

## DNS解析
1浏览器搜索自己的DNS缓存（维护一张域名与IP地址的对应表）
2若没有，则搜索操作系统中的DNS缓存和hosts文件
3若没有，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则通过递归或者迭代的查询方式依次向根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回IP地址给本地域名服务器
4本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来
5操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来
6至此，浏览器已经得到了域名对应的IP地址


## 浏览器中输入URL到返回页面的全过程
第一步，解析域名，找到主机IP
第二步，浏览器利用IP直接与网站主机通信。三次握手
第三步，浏览器向主机发起一个HTTP-GET报文请求。
第四步，服务器响应请求，发回网页内容。浏览器解析网页内容。
[浏览器中输入URL到返回页面的全过程](https://www.cnblogs.com/jiaosq/p/5841366.html)

## 停止等待协议&超时重传
停止等待协议能够在不可靠的传输网络上面实现可靠的通信。每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。分组需要编号。
超时重传是指：只要过了一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间长一些。这种自动重传方式常称为自动重传请求ARQ.


## IP首部
![在这里插入图片描述](https://img-blog.csdn.net/20180924195350449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 协议层
OSI是Open System Interconnect的缩写，意为开放式系统互联。
OSI分层（7层）:物理层、数据链路层、网络层、运输层、会话层、表示层、应用层
TCP/IP分层（4层）:网络接口层、网络层、运输层、应用层
五层协议（5层）:物理层、数据链路层、网络层、运输层、应用层
![在这里插入图片描述](https://img-blog.csdn.net/20180924195356897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## ARP协议的工作原理
ARP是解决同一个局域网上的主机和路由器ip和MAC地址的解析。
首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

## 子网划分
传统的两级ip地址空间利用率很低，一个A类网络可连接的主机数可超过1000万台，但实际连接的主机数并不多。所以需要对网络进行子网划分，通过子网掩码来区分网络。
三级ip地址：<网络号><子网号><主机号>

路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。

## NAT
NAT（Network Address Translation，网络地址转换）是将IP 数据包头中的IP 地址转换为另一个IP 地址的过程。在实际应用中，NAT 主要用于实现私有网络访问公共网络的功能。
DNAT Destination Network Address Translation 目的网络地址转换。
SNAT Source Network Address Translation 源网络地址转换。
[SNAT和DNAT](https://andyyoung01.github.io/2017/03/29/Linux%E7%BD%91%E7%BB%9C%E7%9A%84SNAT%E5%92%8CDNAT/)
[NAT](https://blog.csdn.net/lasoup/article/details/78289735)


## url
url：URI的子集。例如https://www.zhihu.com/question/21950864
uri：21950864



## 对称加密

对称加密：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。

非对称加密：它需要生成两个密钥：公钥(Public Key)和私钥(Private Key)。公钥顾名思义是公开的，任何人都可以获得，而私钥是私人保管的。我们提交代码到github的时候，就可以使用SSH key：在本地生成私钥和公钥，私钥放在本地`.ssh`目录中，公钥放在github网站上，这样每次提交代码，不用麻烦的输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。公钥负责加密，私钥负责解密；或者，私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。

对称加密和非对称加密需要搭配使用更主要的原因是：

1）对称加密：两边需要使用相同的密钥，需要使用一种安全的方式交换密钥，单纯使用对称加密，无法实现密钥交换。

2）非对称加密：只使用非对称加密是可以满足安全性要求的，但是由于非对称加密的计算耗时高于对称加密的2-3个数量级（相同安全加密级别），所以才先使用非对称交换密钥，之后再使用对称加密通信。



## HTTPS

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9KZExrRUk5c1pmZXIxV1NQWWljN0trWWJpYm1wTkYwVnVPWTdsbU1qb0U4SVZPejhpYzNBQUZFWkFFOGliUmVhSjc4dWxWMXU4TTdQU1pGMzJwWllNS0tZV0EvNjQw?x-oss-process=image/format,png)

1. 客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；
2. 互相传递三个随机数，之后通过这随机数来生成一个对称密钥；
3. 互相发送使用对称秘钥加密的握手完成信息，确认密钥，然后握手结束；
4. 数据通讯开始，都使用同一个对称密钥来加解密；