<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [线程池](#%E7%BA%BF%E7%A8%8B%E6%B1%A0)
  - [线程池原理](#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86)
  - [线程池大小](#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F)
  - [关闭线程池](#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0)
- [executor框架](#executor%E6%A1%86%E6%9E%B6)
  - [简介](#%E7%AE%80%E4%BB%8B)
  - [ThreadPoolExecutor Demo](#threadpoolexecutor-demo)
  - [Runnable和Callable的区别](#runnable%E5%92%8Ccallable%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [execute()和submit()](#execute%E5%92%8Csubmit)
  - [常用的线程池](#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0)
    - [FixedThreadPool](#fixedthreadpool)
    - [SingleThreadExecutor](#singlethreadexecutor)
    - [CachedThreadPool](#cachedthreadpool)
    - [ScheduledThreadPoolExecutor](#scheduledthreadpoolexecutor)
- [等待/通知机制](#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6)
- [创建线程的方法](#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95)
- [并发容器](#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8)
  - [ConcurrentHashMap](#concurrenthashmap)
  - [Copy-On-Write](#copy-on-write)
  - [ConcurrentLinkedQueue](#concurrentlinkedqueue)
  - [阻塞队列](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97)
    - [JDK提供的阻塞队列](#jdk%E6%8F%90%E4%BE%9B%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97)
    - [原理](#%E5%8E%9F%E7%90%86)
- [volatile](#volatile)
- [锁](#%E9%94%81)
  - [Synchronized](#synchronized)
    - [作用](#%E4%BD%9C%E7%94%A8)
    - [释放锁](#%E9%87%8A%E6%94%BE%E9%94%81)
    - [实现原理](#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
    - [锁的状态](#%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81)
  - [ReentrantLock](#reentrantlock)
    - [原理](#%E5%8E%9F%E7%90%86-1)
  - [ReentrantLock和synchronized区别](#reentrantlock%E5%92%8Csynchronized%E5%8C%BA%E5%88%AB)
  - [锁的分类](#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB)
    - [公平锁与非公平锁](#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81)
    - [共享式与独占式锁](#%E5%85%B1%E4%BA%AB%E5%BC%8F%E4%B8%8E%E7%8B%AC%E5%8D%A0%E5%BC%8F%E9%94%81)
    - [悲观锁与乐观锁](#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81)
      - [CAS](#cas)
  - [锁的实现](#%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0)
- [Daemon Thread](#daemon-thread)
- [并发工具](#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7)
  - [CountDownLatch](#countdownlatch)
  - [CyclicBarrier](#cyclicbarrier)
  - [CyclicBarrier和CountDownLatch区别](#cyclicbarrier%E5%92%8Ccountdownlatch%E5%8C%BA%E5%88%AB)
  - [Semaphore](#semaphore)
- [并发的条件](#%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9D%A1%E4%BB%B6)
- [进程线程](#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B)
  - [线程状态](#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81)
  - [中断](#%E4%B8%AD%E6%96%AD)
  - [join/yeild/sleep/wait/park](#joinyeildsleepwaitpark)
  - [wait()和sleep()的区别](#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB)
- [原子类](#%E5%8E%9F%E5%AD%90%E7%B1%BB)
  - [基本类型原子类](#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB)
  - [数组类型原子类](#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB)
  - [引用类型原子类](#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB)
- [AQS](#aqs)
  - [自定义同步器](#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8)
- [Condition](#condition)
  - [实现原理](#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1)
- [LockSupport](#locksupport)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 线程池

**使用线程池的好处**：

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。统一管理线程，避免系统创建大量同类线程而导致消耗完内存。

```
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);
```
### 线程池原理

创建新的线程需要获取全局锁，通过这种设计可以尽量避免获取全局锁，当 ThreadPoolExecutor 完成预热之后（当前运行的线程数大于等于 corePoolSize），提交的大部分任务都会被放到 BlockingQueue。

![](../img/thread-pool.png)

ThreadPoolExecutor 的通用构造函数：

```
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);
```

- corePoolSize：当有新任务时，如果线程池中线程数没有达到线程池的基本大小，则会创建新的线程执行任务，否则将任务放入阻塞队列。当线程池中存活的线程数总是大于 corePoolSize 时，应该考虑调大 corePoolSize。

- maximumPoolSize：当阻塞队列填满时，如果线程池中线程数没有超过最大线程数，则会创建新的线程运行任务。否则根据拒绝策略处理新任务。非核心线程类似于临时借来的资源，这些线程在空闲时间超过 keepAliveTime 之后，就应该退出，避免资源浪费。

- BlockingQueue：存储等待运行的任务。

- keepAliveTime：**非核心线程**空闲后，保持存活的时间。

- TimeUnit：时间单位

  ```java
  TimeUnit.DAYS
  TimeUnit.HOURS
  TimeUnit.MINUTES
  TimeUnit.SECONDS
  TimeUnit.MILLISECONDS
  TimeUnit.MICROSECONDS
  TimeUnit.NANOSECONDS
  ```
- ThreadFactory：每当线程池创建一个新的线程时，都是通过线程工厂方法来完成的。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建新线程就会调用它。

  ```java
  public class MyThreadFactory implements ThreadFactory {
      private final String poolName;
      
      public MyThreadFactory(String poolName) {
          this.poolName = poolName;
      }
      
      public Thread newThread(Runnable runnable) {
          return new MyAppThread(runnable, poolName);//将线程池名字传递给构造函数，用于区分不同线程池的线程
      }
  }
  ```

- RejectedExecutionHandler：当队列和线程池都满了时，根据拒绝策略处理新任务。

  ```java
  AbortPolicy：默认的策略，直接抛出RejectedExecutionException
  DiscardPolicy：不处理，直接丢弃
  DiscardOldestPolicy：将等待队列队首的任务丢弃，被拒绝的任务重新添加到等待队列
  CallerRunsPolicy：由调用线程处理该任务
  ```

### 线程池大小

如果线程池线程数量太小，当有大量请求需要处理，系统响应比较慢影响体验，甚至会出现任务队列大量堆积任务导致OOM。

如果线程池线程数量过大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换（cpu给线程分配时间片，当线程的cpu时间片用完后保存状态，以便下次继续运行），从而增加线程的执行时间，影响了整体执行效率。

CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止某些原因导致的任务暂停（线程阻塞，如io操作，等待锁，线程sleep）而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。

I/O 密集型任务(2N)： 系统会用大部分的时间来处理 I/O 交互，而线程等待 I/O 操作会被阻塞，释放 cpu，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法：最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (I/O耗时/CPU耗时))，一般可设置为2N。

### 关闭线程池

shutdown()：

将线程池状态置为`SHUTDOWN`,并不会立即停止：

- 停止接收外部提交的任务
- 内部正在跑的任务和队列里等待的任务，会执行完
- 等到第二步完成后，才真正停止

shutdownNow()：

将线程池状态置为`STOP`。企图立即停止，事实上不一定：

- 跟shutdown()一样，先停止接收外部提交的任务
- 忽略队列里等待的任务
- 尝试将正在跑的任务`interrupt`中断（不一定中断成功，取决于任务响应中断的逻辑）
- 返回未执行的任务列表



## executor框架

1.5后引入的Executor框架的最大优点是把任务的提交和执行解耦。当提交一个Callable对象给ExecutorService，将得到一个Future对象，调用Future对象的get方法等待执行结果就好了。Executor框架的内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。

### 简介

executor框架由3部分组成：任务、任务的执行、异步计算的结果
- 任务。包括被执行任务需要实现的接口：Runnable和Callable接口。
- 任务的执行。Executor接口是Executor框架的基础，它将任务的提交和执行分离开。ExecutorService接口继承于Executor，有两个实现类`ThreadPoolExecutor`和`ScheduledThreadPoolExecutor`。
- 异步计算的结果。包括future接口和实现future接口的FutureTask，调用future.get()会阻塞当前线程直到任务完成，future.cancel()可以取消执行任务。

### ThreadPoolExecutor Demo

使用 `ThreadPoolExecutor` 构造函数自定义参数的方式来创建线程池。

```java
public class ThreadPoolExecutorDemo {
    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int QUEUE_CAPACITY = 100;
    private static final long KEEP_ALIVE_TIME = 1L;

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );

        for (int i = 0; i < 10; i++) {
            Callable worker = () -> {
                System.out.println(Thread.currentThread().getName());
                return "ok";
            };
            Future<String> f = executor.submit(worker);
            f.get();
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
        }
        System.out.println("Finished all threads");
    }
}
```

### Runnable和Callable的区别

Runnable 有一定的局限，它不能返回值或者抛出一个受检查的异常。许多任务都存在延迟的计算，如执行数据库查询、从网络获取资源和复杂的计算等。Callable 是一种可以返回值或抛出受检查异常的任务。

```
Executors.callable(Runnable task);//runnable转化为callable
ExecutorService.execute(Runnable);
ExecutorService.submit(Runnable/Callable);//submit callable任务有返回值
```

### execute()和submit()

`execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；

`submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功，并且可以通过 `Future` 的 `get()`方法来获取返回值，`get()`方法会阻塞当前线程直到任务完成，而使用 `get（long timeout, TimeUnit unit）`方法则会阻塞当前线程一段时间后立即返回，无论任务是否执行完。

### 常用的线程池

#### FixedThreadPool

固定线程数的线程池。

```
public static ExecutorService newFixedThreadPool(int nThreads) {
	return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
}
```
使用无界队列 LinkedBlockingQueue（队列容量为 Integer.MAX_VALUE），运行中的线程池不会拒绝任务，即不会调用RejectedExecutionHandler.rejectedExecution()方法。

maxThreadPoolSize 是无效参数，故将它的值设置为与 coreThreadPoolSize 一致。

keepAliveTime 也是无效参数（没有非核心线程），设置为0L，即有空闲的线程会被立即终止。

不推荐使用：FixedThreadPool 不会拒绝任务，在任务比较多的时候会导致 OOM。

#### SingleThreadExecutor

只有一个线程的线程池。

```
public static ExecutionService newSingleThreadExecutor() {
	return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
}
```
使用无界队列 LinkedBlockingQueue。线程池只有一个运行的线程，新来的任务放入工作队列，线程处理完任务就循环从队列里获取任务执行。保证顺序的执行各个任务。

不推荐使用：同 FixedThreadPool，在任务比较多的时候会导致 OOM。

#### CachedThreadPool

根据需要创建新线程的线程池。

```
public static ExecutorService newCachedThreadPool() {
	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
}
```
如果主线程提交任务的速度高于 `maximumPool` 中线程处理任务的速度时，`CachedThreadPool` 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。

使用没有容量的SynchronousQueue作为线程池工作队列，当线程池有空闲线程时，`SynchronousQueue.offer(Runnable task)`提交的任务会被空闲线程处理，否则会创建新的线程处理任务。

不推荐使用原因：`CachedThreadPool`允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

#### ScheduledThreadPoolExecutor

在给定的延迟后运行任务，或者定期执行任务。在实际项目中基本不会被用到，因为有其他方案选择比如`quartz`。

使用的任务队列 `DelayQueue` 封装了一个 `PriorityQueue`，`PriorityQueue` 会对队列中的任务进行排序，时间早的任务先被执行(即`ScheduledFutureTask` 的 `time` 变量小的先执行)，如果time相同则先提交的任务会被先执行(`ScheduledFutureTask` 的 `squenceNumber` 变量小的先执行)。

执行周期任务步骤：

1. 线程从 `DelayQueue` 中获取已到期的 `ScheduledFutureTask（DelayQueue.take()）`。到期任务是指 `ScheduledFutureTask`的 time 大于等于当前系统的时间；
2. 执行这个 `ScheduledFutureTask`；
3. 修改 `ScheduledFutureTask` 的 time 变量为下次将要被执行的时间；
4. 把这个修改 time 之后的 `ScheduledFutureTask` 放回 `DelayQueue` 中（`DelayQueue.add()`)。

![](../img/scheduled-task.jpg)





## 等待/通知机制
调用wait/notify需要先获得对象的锁。调用wait之后线程释放锁，将线程放到对象的等待队列，当通知线程调用notify后，等待线程并不会立即从wait返回，得等通知线程释放锁，从wait方法返回前提是线程获得锁。
等待通知机制依托于同步机制，目的是确保等待线程从wait方法返回时能感知到通知线程对对象的变量值的修改。



## 创建线程的方法

- 通过扩展Thread类来创建多线程
- 通过实现Runnable接口来创建多线程，可实现线程间的资源共享
- 实现Callable接口，通过FutureTask接口创建线程。
- 使用Executor框架来创建线程池。

Callable 创建线程代码：

```
public class CallalbleTest {
    public static void main(String[] args) {
        CallableDemo cd = new CallableDemo();

        //异步计算的结果
        FutureTask<Integer> result = new FutureTask<>(cd);

        new Thread(result).start();

        try {
            //等待任务完成，返回结果
            int sum = result.get();
            System.out.println(sum);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }

}
class CallableDemo implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        int sum = 0;

        for (int i = 0; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }
}
```
使用 Executor 创建线程代码：

```java
public class ExecutorsDemo {
    public static void main(String[] args) {
        //获取ExecutorService实例
        ExecutorService executorService = Executors.newCachedThreadPool();
        //提交任务
        executorService.submit(new RunnableDemo());
    }
}

class RunnableDemo implements Runnable {

    @Override
    public void run() {
        System.out.println("Tyson");
    }
}
```

实现Runnable接口比继承Thread类所具有的优势：

1. 资源共享，适合多个相同的程序代码的线程去处理同一个资源
2. 可以避免java中的单继承的限制
3. 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类



## 并发容器

JDK 提供的这些容器大部分在 `java.util.concurrent` 包中。

- **ConcurrentHashMap:** 线程安全的 HashMap
- **CopyOnWriteArrayList:** 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.
- **ConcurrentLinkedQueue:** 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
- **BlockingQueue:** 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
- **ConcurrentSkipListMap:** 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

### ConcurrentHashMap

多线程环境下，使用Hashmap进行put操作会引起死循环，应该使用支持多线程的 ConcurrentHashMap。
JDK1.7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度。Segment继承了ReentrantLock，所以它就是一种可重入锁。默认分配16个segment，允许16个线程并发执行。Segment维护了一个HashEntry**数组**，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计size时，比较统计前后modCount是否发生变化。如果没有变化，则直接返回size。否则，需要依次锁住所有的Segment来计算。当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能。

![在这里插入图片描述](../img/ConcurrentHashMap-segment.jpg)

JDK1.8 ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，采用数组+链表/红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，相比1.7锁定HashEntry数组，锁粒度更小，支持更高的并发量。当链表长度过长时，Node会转换成TreeNode，提高查找速度。

![](../img/JDK1.8-ConcurrentHashMap-Structure.jpg)

ConcurrentHashMap调用get的时候不加锁，原因是node（1.7是HashEntry）成员val和指针next是用volatile修饰的，更改后的值会立刻刷新到主存中，保证了可见性，node数组也用volatile修饰，可以保证扩容时对其他线程具有可见性。

put 操作流程：
1. 如果没有初始化就先调用initTable（）方法来进行初始化过程
2. 如果没有hash冲突就直接CAS插入
3. 如果还在进行扩容操作就先进行扩容
4. 如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入
5. 链表的数量大于阈值8，就要转换成红黑树的结构
6. 如果添加成功就调用addCount()方法统计size，并且检查是否需要扩容

### Copy-On-Write

写时复制。当我们往容器添加元素时，不直接往容器添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新容器。这样做的好处就是可以对Copy-On-Write容器进行并发的读而不需要加锁，因为当前容器不会被修改。

从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。

CopyOnWriteArrayList中add方法添加的时候是需要加锁的，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，还是可以读到旧的数据。

缺点：

- 内存占用问题。由于CopyOnWrite的写时复制机制，在进行写操作的时候，内存里会同时驻扎两个对象的内存。
- CopyOnWrite容器不能保证数据的实时一致性，可能读取到旧数据。

### ConcurrentLinkedQueue

非阻塞队列。高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，通过 CAS 操作实现。

如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。适合在对性能要求相对较高，同时有多个线程对队列进行读写的场景。

**非阻塞队列中的几种主要方法：**
add(E e) : 将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；
remove() ：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；
offer(E e) ：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；
poll() ：移除并获取队首元素，若成功，则返回队首元素；否则返回null；
peek() ：获取队首元素，若成功，则返回队首元素；否则返回null

对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。

### 阻塞队列

阻塞队列是java.util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。BlockingQueue 适合用于作为数据共享的通道。

使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。

阻塞队列和一般的队列的区别就在于：

1. 多线程支持，多个线程可以安全的访问队列
2. 阻塞操作，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满。

**阻塞的队列方法**
put(E e) : 用来向队尾存入元素，如果队列满，则等待；
take() : 用来从队首取元素，如果队列为空，则等待；
offer(E e,long timeout, TimeUnit unit) : 用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；
poll(long timeout, TimeUnit unit) : 用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素；

#### JDK提供的阻塞队列

JDK 7 提供了7个阻塞队列，如下

1、**ArrayBlockingQueue** 

有界阻塞队列，底层采用数组实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不能保证线程访问队列的公平性，参数`fair`可用于设置线程是否公平访问队列。为了保证公平性，通常会降低吞吐量。

```java
private static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);//fair
```

2、**LinkedBlockingQueue**

LinkedBlockingQueue是一个用单向链表实现的有界阻塞队列，可以当做无界队列也可以当做有界队列来使用。此队列的默认和最大长度为`Integer.MAX_VALUE`。与 ArrayBlockingQueue 相比起来具有更高的吞吐量。通常在创建 LinkedBlockingQueue 对象时，会指定队列最大的容量。此队列按照先进先出的原则对元素进行排序。

3、**PriorityBlockingQueue** 

支持优先级的**无界**阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现`compareTo()`方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数`Comparator`来进行排序。

PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会**自动扩容**。

PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。

4、**DelayQueue** 

支持延时获取元素的无界阻塞队列。队列使用PriorityBlockingQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。

5、**SynchronousQueue**

不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。支持公平访问队列。

SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。

6、**LinkedTransferQueue**

由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法。

transfer方法：如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。

tryTransfer方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。

#### 原理

JDK使用通知模式实现阻塞队列。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞主生产者，当消息者消费了一个队列中的元素后，会通知生产者当前队列可用。

ArrayBlockingQueue使用Condition来实现：

```java
private final Condition notEmpty;

private final Condition notFull;

public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0) // 队列为空时，阻塞当前消费者
            notEmpty.await();
        return dequeue();
    } finally {
        lock.unlock();
    }
}

public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}

private void enqueue(E x) {
    final Object[] items = this.items;
    items[putIndex] = x;
    if (++putIndex == items.length)
          putIndex = 0;
     count++;
     notEmpty.signal(); // 队列不为空时，通知消息者获取元素
}
```



## volatile

共享变量存储在主内存里，每个线程都有自己私有的本地内存，本地内存保存了共享变量的副本，线程对变量的操作都在本地内存中进行，不能直接读写主内存中的变量。

![jmm模型](https://img-blog.csdn.net/20180922084352403?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

volatile是轻量级的同步机制，volatile保证变量对所有线程的可见性，不保证原子性。

1. 当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中。
2. 这个写操作会使其他线程中的缓存无效。
3. 其他线程需要操作该变量时，会重新到主内存读取最新的值。

volatile不能保证volatile变量复合操作的原子性(i++，读取/加一/赋值)，在多线程环境下，有可能线程A将i读取到本地内存中，此时其他线程可能已经将i增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了i的结果不符合预期。不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。

MESI（缓存一致性协议）：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，就会从内存重新读取。

volatile关键字的两个作用：
1）保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。

指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。
[指令重排导致单例模式失效](https://blog.csdn.net/jiyiqinlovexx/article/details/50989328)
java编译器会在生成指令系列时在适当的位置会插入`内存屏障`指令来禁止处理器重排序。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。对一个volatile字段进行写操作，Java内存模型将在写操作后插入一个写屏障指令，这个指令会把之前的写入值都刷新到缓存。

线程不安全的单例：
```java
public class wrongsingleton {
    private static volatile wrongsingleton _instance = null; 
 
    private wrongsingleton() {}
 
    public static wrongsingleton getInstance() {
 
        if (_instance == null) {
            _instance = new wrongsingleton();
            System.out.println("--initialized once.");
        }
 
        return _instance;
    }
}
 
private static void testInit(){
         
        Thread t1 = new Thread(new LoopInit());
        Thread t2 = new Thread(new LoopInit2());
        Thread t3 = new Thread(new LoopInit());
        Thread t4 = new Thread(new LoopInit2());
        t1.start();
        t2.start();
        t3.start();
        t4.start();
         
        while (t1.isAlive() || t2.isAlive() || t3.isAlive()|| t4.isAlive()) {
             
        }
 
    }
```


## 锁

### Synchronized

较常用的用于保证线程安全的方式。当一个线程获取到锁时，其他线程都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程才有机会获取到锁。

- 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁（类的字节码文件） 。
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。

获取了类锁的线程和获取了对象锁的线程是不冲突的。

#### 作用

synchronized，对象的内置锁，通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的原子性和其他线程对变量的可见性，从而确保了并发情况下的线程安全。

#### 释放锁

当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。
当一个线程执行的代码出现异常时，其所持有的锁会自动释放。

#### 实现原理

synchronized通过对象内部的监视器（monitor）实现，每个对象都有一个monitor，当对象的monitor被持有时，则它处于锁定的状态。代码块的同步是使用monitorenter和monitorexit指令实现的，monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处或异常处。

#### 锁的状态

JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

- 无锁状态：对资源进行锁定，所有的线程都能访问并修改同一个资源，如果没有冲突就修改成功并退出，否则就会继续循环尝试。如乐观锁。

- 偏向锁：当线程访问同步块并获取锁时，会在对象头和锁记录中存储锁偏向的线程id，以后该线程进入和退出同步块时，只需简单测试一下对象头的mark word中是否存储着指向当前线程的偏向锁，如果测试成功，则线程获取锁成功，否则，需再测试一下mark word中偏向锁标识是否是1，是的话则使用CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
  **偏向锁偏向于第一个获得它的线程，如果在后面的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。也就是说，偏向锁在无竞争的情况下会把整个同步都消除掉。当存在锁竞争的时候，偏向锁会升级为轻量级锁。**
  适用场景：在锁无竞争的情况下使用，在线程没有执行完同步代码之前，没有其它线程去竞争锁，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，会做很多额外操作，导致性能下降。

- 轻量级锁
  加锁过程：线程执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的mark word复制到锁记录（displaced mark word）中，然后线程尝试使用cas将对象头的mark word替换为指向锁记录的指针。如果成功，则当前线程获得锁，否则表示有其他线程竞争锁，当前线程便尝试使用自旋来获得锁。当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
  解锁过程：使用原子的cas操作将displaced mark word替换回到对象头，如果成功则解锁成功，否则表明有锁竞争，锁会膨胀成重量级锁。

  **在没有多线程竞争的前提下，使用轻量级锁可以减少传统的重量级锁使用操作系统互斥量（申请互斥锁）产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级锁将很快膨胀为重量级锁！**

- 重量级锁：当一个线程获取到锁时，其他线程都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程才有机会获取到锁。

  synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中，保证了可见性。

- 自旋锁：一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程比较浪费资源。自旋锁就是让该线程等待一段时间，执行一段无意义的循环，不会被立即挂起，看持有锁的线程是否会很快释放锁。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，这样反而会带来性能上的浪费。所以自旋的次数必须要有一个限度，如果自旋超过了限定次数仍然没有获取到锁，则应该被挂起。

- 自适应自旋锁：JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

- 锁消除：虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。

- 锁粗化：如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗，使用锁粗化减少锁操作的开销。

### ReentrantLock

重入锁，支持一个线程对资源的重复加锁。该锁的还支持设置获取锁时的公平和非公平性。

#### 原理

ReentrantLock是通过组合自定义同步器来实现锁的获取与释放。当线程尝试获取同步状态时，首先判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。获取同步状态失败，则该线程会被构造成node节点放到同步队列中。

如果锁被获取了n次，那么前n-1次 tryRelease(int releases)方法必须返回false，第n次调用tryRelease()之后，同步状态完全释放（值为0），才会返回true。

### ReentrantLock和synchronized区别

1. 使用synchronized关键字实现同步，线程执行完同步代码块会自动释放锁，而ReentrantLock需要手动释放锁。
2. synchronized是非公平锁，ReentrantLock可以设置为公平锁。
3. ReentrantLock是可中断的，持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待。而synchonized会无限期等待下去。

### 锁的分类

#### 公平锁与非公平锁

按照线程访问顺序获取对象锁。synchronized 和 Lock 默认都是非公平锁，公平锁会影响性能。

#### 共享式与独占式锁

共享式与独占式的最主要区别在于：同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。

#### 悲观锁与乐观锁

悲观锁，每次访问资源都会加锁，执行完同步代码释放锁，synchronized 属于悲观锁。

乐观锁，它假设自己在使用数据时不会有别的线程修改这个数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则自动重试直到成功。乐观锁最常见的实现就是CAS。

![](../img/optimistic-lock.jpg)

适用场景：

- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

##### CAS

CAS全称 Compare And Swap（比较与交换），是一种无锁算法，也是乐观锁的主要实现方式。CAS 在不使用锁的情况下实现多线程之间的变量同步。ReentrantLock 内部的 AQS 和原子类内部都使用了 CAS。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

只有当 V 的值等于 A 时，才会使用原子方式用新值B来更新V的值，否则采用自旋的方式继续进行 CAS 操作。

以 AtomicInteger 为例，AtomicInteger 的 getAndIncrement()方法底层就是CAS实现，关键代码是 `compareAndSwapInt(obj, offset, expect, update)`，其含义就是，如果`obj`内的`value`和`expect`相等，就证明没有其他线程改变过这个变量，那么就更新它为`update`，如果不相等，那就采用自旋的方式继续进行`CAS`操作。

CAS 三大问题：

1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。

   JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，原子更新带有版本号的引用类型。

2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。

   Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

### 锁的实现

- synchronized：重量级锁，隐式支持重进入，即线程获取对象锁之后，尽管锁没有释放，此线程可以再次获取锁。
- ReentrantLock：可重入锁，支持同一个线程对资源的重复加锁，可以设置公平和非公平。底层是使用队列同步器AbstractQueueSynchronizer实现。
- ReentrantReadWriteLock：读写锁，同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和写线程会被堵塞。通过自定义队列同步器实现同步功能。将状态变量按位分割，高16位表示读，低16位表示写。



## Daemon Thread
在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC
将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。



## 并发工具

在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段。

### CountDownLatch

CountDownLatch用于某个线程等待其他线程**执行完任务**再执行。常见的应用场景是开启多个线程同时执行某个任务，等到所有任务执行完再执行特定操作，如汇总统计结果。

```
public class CountDownLatchDemo {
    static final int N = 4;
    static CountDownLatch latch = new CountDownLatch(N);

    public static void main(String[] args) throws InterruptedException {

       for(int i = 0; i < N; i++) {
            new Thread(new Thread1()).start();
       }

       latch.await(1000, TimeUnit.MILLISECONDS); //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行;等待timeout时间后count值还没变为0的话就会继续执行
       System.out.println("task finished");
    }

    static class Thread1 implements Runnable {

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + "starts working");
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
            }
        }
    }
}
```

运行结果：

```java
Thread-0starts working
Thread-1starts working
Thread-2starts working
Thread-3starts working
task finished
```

### CyclicBarrier

CyclicBarrier(同步屏障)，用于一组线程互相等待到某个状态，然后这组线程再**同时**执行。

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
}
public CyclicBarrier(int parties) {
}
```

参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。

```java
public class CyclicBarrierTest {
    // 请求的数量
    private static final int threadCount = 10;
    // 需要同步的线程数量
    private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5);

    public static void main(String[] args) throws InterruptedException {
        // 创建线程池
        ExecutorService threadPool = Executors.newFixedThreadPool(10);

        for (int i = 0; i < threadCount; i++) {
            final int threadNum = i;
            Thread.sleep(1000);
            threadPool.execute(() -> {
                try {
                    test(threadNum);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            });
        }
        threadPool.shutdown();
    }

    public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {
        System.out.println("threadnum:" + threadnum + "is ready");
        try {
            /**等待60秒，保证子线程完全执行结束*/
            cyclicBarrier.await(60, TimeUnit.SECONDS);
        } catch (Exception e) {
            System.out.println("-----CyclicBarrierException------");
        }
        System.out.println("threadnum:" + threadnum + "is finish");
    }

}
```

运行结果如下，可以看出CyclicBarrier是可以重用的：

```java
threadnum:0is ready
threadnum:1is ready
threadnum:2is ready
threadnum:3is ready
threadnum:4is ready
threadnum:4is finish
threadnum:3is finish
threadnum:2is finish
threadnum:1is finish
threadnum:0is finish
threadnum:5is ready
threadnum:6is ready
...
```

当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。

### CyclicBarrier和CountDownLatch区别

CyclicBarrier 和 CountDownLatch 都能够实现线程之间的等待。

CountDownLatch用于某个线程等待其他线程**执行完任务**再执行。CyclicBarrier用于一组线程互相等待到某个状态，然后这组线程再**同时**执行。
CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。

### Semaphore

Semaphore类似于锁，它用于控制同时访问特定资源的线程数量，控制并发线程数。

```
public class SemaphoreDemo {
    public static void main(String[] args) {
        final int N = 7;
        Semaphore s = new Semaphore(3);
        for(int i = 0; i < N; i++) {
            new Worker(s, i).start();
        }
    }

    static class Worker extends Thread {
        private Semaphore s;
        private int num;
        public Worker(Semaphore s, int num) {
            this.s = s;
            this.num = num;
        }

        @Override
        public void run() {
            try {
                s.acquire();
                System.out.println("worker" + num +  " using the machine");
                Thread.sleep(1000);
                System.out.println("worker" + num +  " finished the task");
                s.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

运行结果如下，可以看出并非按照线程访问顺序获取资源的锁，即

```java
worker0 using the machine
worker1 using the machine
worker2 using the machine
worker2 finished the task
worker0 finished the task
worker3 using the machine
worker4 using the machine
worker1 finished the task
worker6 using the machine
worker4 finished the task
worker3 finished the task
worker6 finished the task
worker5 using the machine
worker5 finished the task
```



## 并发的条件

并发程序要正确地执行，必须要保证原子性、可见性以及有序性。



## 进程线程
进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。
线程是比进程更小的执行单位，它是在一个进程中独立的控制流，即程序内部的控制流。

### 线程状态

初始(NEW)：线程被构建，还没有调用 start()。

运行(RUNNABLE)：包括操作系统的就绪和运行两种状态。

阻塞(BLOCKED)：一般是被动的，在抢占资源中得不到资源，被动的挂起在内存，等待某种资源或信号量（即有了资源）将他唤醒。释放CPU，不释放内存。

等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。

超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。

终止(TERMINATED)：表示该线程已经执行完毕。

![](../img/thread-status.jpeg)

### 中断

[线程中断](https://zhuanlan.zhihu.com/p/45667127)

线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑取决于目标线程。

线程中断三个重要的方法：

**1、java.lang.Thread#interrupt**

调用目标线程的interrupt()方法，给目标线程发一个中断信号，线程被打上中断标记。

**2、java.lang.Thread#isInterrupted()**

判断目标线程是否被中断，不会清除中断标记。

**3、java.lang.Thread#interrupted**

判断目标线程是否被中断，会清除中断标记。

```java
private static void test2() {
    Thread thread = new Thread(() -> {
        while (true) {
            Thread.yield();

            // 响应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Java技术栈线程被中断，程序退出。");
                return;
            }
        }
    });
    thread.start();
    thread.interrupt();
}
```

### join/yeild/sleep/wait/park

thread.join()，在main中创建了thread线程，在main中调用了thread.join()/thread.join(long millis)，main线程放弃cpu控制权，线程进入WAITING/TIMED_WAITING状态，等到thread线程执行完才继续执行main线程。

Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。

Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，让出cpu资源，但不释放对象锁，指定时间到后又恢复运行。作用：给其它线程执行机会的最佳方式。

obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。

obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。

LockSupport.park()/LockSupport.parkNanos(long nanos)/LockSupport.parkUntil(long deadlines), 当前线程进入WAITING/TIMED_WAITING状态。对比wait方法,不需要获得锁就可以让线程进入WAITING/TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。

### wait()和sleep()的区别

相同点：

1. 使当前线程暂停运行，把机会交给其他线程
2. 任何线程在等待期间被中断都会抛出InterruptedException

不同点：

1. wait() 是Object超类中的方法；而sleep()是线程Thread类中的方法

2. 对锁的持有不同，wait()会释放锁，而sleep()并不释放锁

3. 唤醒方法不完全相同，wait() 依靠notify或者notifyAll 、中断、达到指定时间来唤醒；而sleep()到达指定时间被唤醒

4. 使用位置不同，wait只能在同步代码块或同步控制块中使用，而sleep可以在任何位置使用



## 原子类

###  基本类型原子类

使用原子的方式更新基本类型

- AtomicInteger：整型原子类
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

AtomicInteger 类常用的方法：

```java
public final int get() //获取当前的值
public final int getAndSet(int newValue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement() //获取当前的值，并自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。

### 数组类型原子类

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整形数组原子类
- AtomicLongArray：长整形数组原子类
- AtomicReferenceArray ：引用类型数组原子类

AtomicIntegerArray 类常用方法：

```java
public final int get(int i) //获取 index=i 位置元素的值
public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue
public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值
boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

### 引用类型原子类

- AtomicReference：引用类型原子类
- AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
- AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来



## AQS

AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。

![](../img/aqs.png)

AQS使用一个Volatile的int类型的成员变量state来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。

```java
private volatile int state;//共享变量，使用volatile修饰保证线程可见性
```

同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列并进行自旋，当同步状态释放时，会把首节中的后继节点对应的线程唤醒，使其再次尝试获取同步状态。

### 自定义同步器

```java
public class LeeLock  {

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire (int arg) {
            return compareAndSetState(0, 1);
        }

        @Override
        protected boolean tryRelease (int arg) {
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively () {
            return getState() == 1;
        }
    }
    
    private Sync sync = new Sync();
    
    public void lock () {
        sync.acquire(1);
    }
    
    public void unlock () {
        sync.release(1);
    }
}
```

实现同步功能。代码每次运行结果都会是20000。

```java
public class LeeMain {

    static int count = 0;
    static LeeLock leeLock = new LeeLock();

    public static void main (String[] args) throws InterruptedException {

        Runnable runnable = new Runnable() {
            @Override
            public void run () {
                try {
                    leeLock.lock();
                    for (int i = 0; i < 10000; i++) {
                        count++;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    leeLock.unlock();
                }

            }
        };
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(count);
    }
}
```



## Condition

任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。Condition是依赖Lock对象。

一般将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。

### 实现原理

每个Condition对象都包含着一个等待队列，如果一个线程成功获取了锁之后调用了Condition.await()方法，那么该线程将会释放同步状态、唤醒同步队列中的后继节点，然后构造成节点加入等待队列。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。

![image-20200625120610859](C:\Users\Tyson\AppData\Roaming\Typora\typora-user-images\image-20200625120610859.png)

在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。

![image-20200625120005623](C:\Users\Tyson\AppData\Roaming\Typora\typora-user-images\image-20200625120005623.png)

当前线程获取了锁之后，调用Condition的signal()方法，会将节点移到同步队列中，然后使用LockSupport唤醒在等待队列中等待时间最长的节点（首节点），然后该节点的线程会参与到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。

![image-20200625120642426](C:\Users\Tyson\AppData\Roaming\Typora\typora-user-images\image-20200625120642426.png)



## LockSupport

LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。