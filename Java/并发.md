## 线程池
```
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);
```
- corePoolSize：当有新任务时，如果线程池中线程数没有达到线程池的基本大小，则会创建新的线程执行任务，否则将任务放入阻塞队列。
- maximumPoolSize：当阻塞队列填满时，如果线程池中线程数没有超过最大线程数，则会创建新的线程运行任务。否则根据拒绝策略处理新任务。
- BlockingQueue：存储等待运行的任务。
- keepAliveTime：线程空闲后，保持存活的时间。
- TimeUnit：时间单位
```
TimeUnit.DAYS
TimeUnit.HOURS
TimeUnit.MINUTES
TimeUnit.SECONDS
TimeUnit.MILLISECONDS
TimeUnit.MICROSECONDS
TimeUnit.NANOSECONDS
```
- ThreadFactory：通过线程工厂可以给创建的线程设置名字。
- RejectedExecutionHandler：当队列和线程池都满了时，根据拒绝策略处理新任务。
```
AbortPolicy：默认的策略，直接抛出RejectedExecutionException
DiscardPolicy：不处理，直接丢弃
DiscardOldestPolicy：将等待队列队首的任务丢弃，被拒绝的任务重新添加到等待队列
CallerRunsPolicy：由调用线程处理该任务
```
## executor框架
1.5后引入的Executor框架的最大优点是把任务的提交和执行解耦。当提交一个Callable对象给ExecutorService，将得到一个Future对象，调用Future对象的get方法等待执行结果就好了。Executor框架的内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。

executor框架由3部分组成：任务、任务的执行、异步计算的结果
- 任务。包括被执行任务需要实现的接口：Runnable和Callable接口。
- 任务的执行。Executor接口是Executor框架的基础，它将任务的提交和执行分离开。ExecutorService接口继承于Executor，有两个实现类ThreadPoolExecutor和ScheduledThreadPoolExecutor。
- 异步计算的结果。包括future接口和实现future接口的FutureTask。

ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。
ScheduledThreadPoolExecutor用于在一定延迟时间后运行命令或定期执行命令。

Runnable和Callable的区别：当我们把Runnable或Callable的实现类submit给ThreadPoolExecutor或ScheduledPoolExecutor执行时，Runnable不会返回结果，Callable可以返回结果(FutureTask对象)。
```
Executors.callable(Runnable task);
ExecutorService.execute(Runnable);
ExecutorService.submit(Runnable/Callable);
```

工具类Executors可以创建三种类型的ThreadPoolExecutor。
```
public static ExecutorService newFixedThreadPool(int nThreads) {
	return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
}
```
固定线程数的线程池。使用无界队列，运行中的线程池不会拒绝任务，即不会调用RejectedExecutionHandler.rejectedExecution()方法。

```
public static ExecutionService newSingleThreadExecutor() {
	return new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
}
```
使用无界队列。线程池只有一个运行的线程，新来的任务放入工作队列，线程处理完任务就循环从队列里获取任务执行。
```
public static ExecutorService newCachedThreadPool() {
	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
}
```
根据需要创建新线程的线程池。使用没有容量的SynchronousQueue作为线程池工作队列，当任务提交的速度快于线程处理任务的速度时，CachedThreadPool会不断创建新线程。

## ReentrantLock和synchronized
采用synchronized关键字实现同步，线程执行完同步代码块会自动释放锁，而ReentrantLock需要手动释放锁。
synchronized是非公平锁，ReentrantLock可以设置为公平锁。
ReentrantLock是等待可中断的，持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待。而synchonized会无限期等待下去。

## join和yeild
sleep执行后线程进入**阻塞状态**；yield执行后线程进入**就绪状态**；join执行后线程进入**阻塞状态**。
main是主线程，在main中创建了thread线程，在main中调用了thread.join()，main线程放弃cpu控制权，thread线程执行完才继续执行main线程。
yield()使得当前运行线程回到可运行状态，以允许具有相同（或更高）优先级的其他线程或自己获得运行机会。使用yield()的目的是让相同优先级的线程之间能适当的**轮转执行**。但是实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。yield()没有导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

## 等待/通知机制
调用wait/notify需要先获得对象的锁
调用wait之后线程释放锁，将线程放到对象的等待队列，当通知线程调用notify后，等待线程并不会立即从wait返回，得等通知线程释放锁，从wait方法返回前提是线程获得锁
等待通知机制依托于同步机制，目的是确保等待线程从wait方法返回时能感知到通知线程对对象的变量值的修改

## 创建线程的方法
- 通过扩展Thread类来创建多线程
- 通过实现Runnable接口来创建多线程，可实现线程间的资源共享
- 实现Callable接口，通过FutureTask接口创建线程。
- 使用Executor框架来创建线程池。
```
public class CallalbleTest {
    public static void main(String[] args) {
        CallableDemo cd = new CallableDemo();

        //异步计算的结果
        FutureTask<Integer> result = new FutureTask<>(cd);

        new Thread(result).start();

        try {
            //等待任务完成，返回结果
            int sum = result.get();
            System.out.println(sum);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }

}
class CallableDemo implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        int sum = 0;

        for (int i = 0; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }
}
```
```
public class ExecutorsDemo {
    public static void main(String[] args) {
        //获取ExecutorService实例
        ExecutorService executorService = Executors.newCachedThreadPool();
        //提交任务
        executorService.submit(new RunnableDemo());
    }
}

class RunnableDemo implements Runnable {

    @Override
    public void run() {
        System.out.println("Tyson");
    }
}
```

实现Runnable接口比继承Thread类所具有的优势：
1）：资源共享，适合多个相同的程序代码的线程去处理同一个资源
2）：可以避免java中的单继承的限制
3）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

## ConcurrentHashMap
多线程环境下，使用Hashmap进行put操作会引起死循环，应该使用支持多线程的 ConcurrentHashMap。
JDK1.7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度。Segment继承了ReentrantLock，所以它就是一种可重入锁。默认分配16个segment，允许16个线程并发执行。Segment维护了一个HashEntry**数组**，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计size时，比较统计前后modCount是否发生变化。如果没有变化，则直接返回size。否则，需要依次锁住所有的Segment来计算。当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200522234622862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1R5c29uMDMxNA==,size_16,color_FFFFFF,t_70)

ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，相比1.7锁定HashEntry数组，锁粒度更小，支持更高的并发量。当链表长度过长时，Node会转换成TreeNode，提高查找速度。

ConcurrentHashMap调用get的时候不加锁，原因是node数组（1.7是HashEntry）成员val和指针next是用volatile修饰的，更改后的值会立刻刷新到主存中，保证了可见性，node数组也用volatile修饰，可以保证扩容时对其他线程具有可见性。

put 操作流程：
1. 如果没有初始化就先调用initTable（）方法来进行初始化过程
2. 如果没有hash冲突就直接CAS插入
3. 如果还在进行扩容操作就先进行扩容
4. 如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入
5. 链表的数量大于阈值8，就要转换成红黑树的结构
6. 如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容

## volatile
当一个变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当其他线程需要读取这个变量时，会去内存中读取新值，保证不同线程对共享变量操作的可见性。

MESI（缓存一致性协议）：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，就会从内存重新读取。

volatile关键字的两个作用：
1）保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。

指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。
[指令重排导致单例模式失效](https://blog.csdn.net/jiyiqinlovexx/article/details/50989328)
java编译器会在生成指令系列时在适当的位置会插入`内存屏障`指令来禁止处理器重排序。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。对一个volatile字段进行写操作，Java内存模型将在写操作后插入一个写屏障指令，这个指令会把之前的写入值都刷新到缓存。

volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性。不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。

线程不安全的单例：
```java
public class wrongsingleton {
    private static volatile wrongsingleton _instance = null; 
 
    private wrongsingleton() {}
 
    public static wrongsingleton getInstance() {
 
        if (_instance == null) {
            _instance = new wrongsingleton();
            System.out.println("--initialized once.");
        }
 
        return _instance;
    }
}
 
private static void testInit(){
         
        Thread t1 = new Thread(new LoopInit());
        Thread t2 = new Thread(new LoopInit2());
        Thread t3 = new Thread(new LoopInit());
        Thread t4 = new Thread(new LoopInit2());
        t1.start();
        t2.start();
        t3.start();
        t4.start();
         
        while (t1.isAlive() || t2.isAlive() || t3.isAlive()|| t4.isAlive()) {
             
        }
 
    }
```
## Java锁的实现
公平锁。按照线程访问顺序获取对象锁。synchronized 和 Lock 默认都是非公平锁，公平锁会影响性能。
共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。
- synchronized：重量级锁，隐式支持重进入，即线程获取对象锁之后，尽管锁没有释放，此线程可以再次获取锁。
- ReentrantLock：可重入锁，支持同一个线程对资源的重复加锁，可以设置公平和非公平。通过组合自定义队列同步器AbstractQueueSynchronizer实现。同步状态为0时表示锁没被占用。
- ReentrantReadWriteLock：读写锁，同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和写线程会别堵塞。通过自定义队列同步器实现同步功能。将状态变量按位分割，高16位表示读，低16位表示写。

## 锁的状态
锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

- 偏向锁：当线程访问同步块并获取锁时，会在对象头和锁记录中存储锁偏向的线程id，以后该线程进入和退出同步块时，只需简单测试一下对象头的mark word中是否存储着指向当前线程的偏向锁，如果测试成功，则线程获取锁成功，否则，需再测试一下mark word中偏向锁标识是否是1，是的话则使用CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
偏向锁使用了一种等到竞争出现才释放锁的机制。只有当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
适用场景：在锁无竞争的情况下使用，在线程没有执行完同步代码之前，没有其它线程去竞争锁，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，会做很多额外操作，导致性能下降。

- 轻量级锁
加锁过程：线程执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的mark word复制到锁记录（displaced mark word）中，然后线程尝试使用cas将对象头的mark word替换为指向锁记录的指针。如果成功，则当前线程获得锁，否则表示有其他线程竞争锁，当前线程便尝试使用自旋来获得锁。
解锁过程：使用原子的cas操作将displaced mark word替换回到对象头，如果成功则解锁成功，否则表明有锁竞争，锁会膨胀成重量级锁。

- 重量级锁：当一个线程获取到锁时，其他线程都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程才有机会获取到锁。
synchronized通过对象内部的监视器（monitor）实现，每个对象都有一个monitor，当对象的monitor被持有时，则它处于锁定的状态。代码块的同步是使用monitorenter和monitorexit指令实现的，monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处或异常处。
synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中，保证了可见性。

- 自旋锁：就是让该线程等待一段时间，执行一段无意义的循环，不会被立即挂起，看持有锁的线程是否会很快释放锁。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，这样反而会带来性能上的浪费。所以自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。

JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

## Daemon Thread
在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC
将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。

## 并发工具
1. CountDownLatch允许一个或多个线程等待其他线程完成操作。常见的应用场景是开启多个线程同时执行某个任务，等到所有任务执行完再汇总统计结果。
2. CyclicBarrier(同步屏障)，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开。
3. Semaphore类似于锁，它用于控制同时访问特定资源的线程数量，控制并发线程数。

CyclicBarrier 和 CountDownLatch 都能够实现线程之间的等待。
CountDownLatch用于某个线程等待其他线程执行完任务再执行。
CyclicBarrier用于一组线程互相等待到某个状态，然后这组线程再同时执行。
CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。

```
public class CountDownLatchDemo {
    static final int N = 8;
    static CountDownLatch latch = new CountDownLatch(N);

    public static void main(String[] args) throws InterruptedException {

       for(int i = 0; i < N; i++) {
            new Thread(new Thread1()).start();
       }

       latch.await(1000, TimeUnit.MILLISECONDS);
       System.out.println("task finished");
    }

    static class Thread1 implements Runnable {

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + "starts working");
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
            }
        }
    }
}
```

```
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        final int N = 5;
        CyclicBarrier barrier = new CyclicBarrier(N, new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " running now.");
            }
        });

        for(int i = 0; i < N; i++) {
            new Thread1(barrier).start();
        }
    }

    static class Thread1 extends Thread {
        private CyclicBarrier barrier;

        public Thread1(CyclicBarrier barrier) {
            this.barrier = barrier;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " running");
            try {
                Thread.sleep(50000);
                System.out.println(Thread.currentThread().getName() + " finished");
                barrier.await(2000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            } catch (TimeoutException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```
public class SemaphoreDemo {
    public static void main(String[] args) {
        final int N = 15;
        Semaphore s = new Semaphore(3);
        for(int i = 0; i < N; i++) {
            new Worker(s, i).start();
        }
    }

    static class Worker extends Thread {
        private Semaphore s;
        private int num;
        public Worker(Semaphore s, int num) {
            this.s = s;
            this.num = num;
        }

        @Override
        public void run() {
            try {
                s.acquire();
                System.out.println("worker" + num +  " using the machine");
                Thread.sleep(1000);
                System.out.println("worker" + num +  " finished the task");
                s.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 并发的条件
并发程序要正确地执行，必须要保证原子性、可见性以及有序性。

## Copy-On-Write
写时复制。当我们往容器添加元素时，不直接往容器添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新容器。这样做的好处就是可以对Copy-On-Write容器进行并发的读而不需要加锁，因为当前容器不会被修改。

从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。

CopyOnWriteArrayList中add方法添加的时候是需要加锁的。读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，还是可以读到旧的数据。

缺点：
- 内存占用问题。由于CopyOnWrite的写时复制机制，在进行写操作的时候，内存里会同时驻扎两个对象的内存。
- 旧的对象和新写入的对象数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。

## 进程线程
进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。
线程是比进程更小的执行单位，它是在一个进程中独立的控制流，即程序内部的控制流。


## 中断

[线程中断](https://zhuanlan.zhihu.com/p/45667127)

线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑取决于目标线程。

线程中断三个重要的方法：

**1、java.lang.Thread#interrupt**

调用目标线程的interrupt()方法，给目标线程发一个中断信号，线程被打上中断标记。

**2、java.lang.Thread#isInterrupted()**

判断目标线程是否被中断，不会清除中断标记。

**3、java.lang.Thread#interrupted**

判断目标线程是否被中断，会清除中断标记。

```java
private static void test2() {
    Thread thread = new Thread(() -> {
        while (true) {
            Thread.yield();

            // 响应中断
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Java技术栈线程被中断，程序退出。");
                return;
            }
        }
    });
    thread.start();
    thread.interrupt();
}
```


## CAS

synchronized 属于悲观锁，每次访问资源都会加锁，执行完同步代码释放锁。乐观锁则相反，它假设每次只有自己访问资源，如果发生冲突，则重试直到成功，乐观锁最常见的实现就是CAS。

ReentrantLock 内部的 AQS 和原子类内部都使用了 CAS。

以 AtomicInteger 为例，AtomicInteger 的 getAndIncrement()方法底层就是CAS实现，关键代码是 `compareAndSwapInt（obj, offset, expect, update）`，其含义就是，如果`obj`内的`value`和`expect`相等，就证明没有其他线程改变过这个变量，那么就更新它为`update`，如果不相等，那就采用自旋的方式继续进行`CAS`操作。

## Synchronized
Java中每个对象都有一个内置锁，而synchronized就是使用对象的内置锁来将代码块(方法)锁定的。
**作用**：Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的原子性和其他线程对变量的可见性，从而确保了并发情况下的线程安全。synchronized保证了对变量操作的原子性，被保护的代码块是一次被执行的，没有任何线程会同时访问；synchronized还保证了其他线程对变量的可见性，当执行完synchronized之后，修改后的变量对其他的线程是可见的。
synchronized可以修饰普通方法，代码块和静态方法。修饰静态方法获取的是类锁（类的字节码文件）。获取了类锁的线程和获取了对象锁的线程是不冲突的。
**什么时候释放锁？**
当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。
当一个线程执行的代码出现异常时，其所持有的锁会自动释放。



## 阻塞队列

实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。

阻塞的意思是如果队满加入或者对空输出都是需要需要等待。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。

### 阻塞和非阻塞的区别

1.非阻塞队列中的几种主要方法：
add(E e) : 将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；
remove() ：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；
offer(E e) ：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；
poll() ：移除并获取队首元素，若成功，则返回队首元素；否则返回null；
peek() ：获取队首元素，若成功，则返回队首元素；否则返回null

对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。

2.阻塞的队列方法
put(E e) : 用来向队尾存入元素，如果队列满，则等待；
take() : 用来从队首取元素，如果队列为空，则等待；
offer(E e,long timeout, TimeUnit unit) : 用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；
poll(long timeout, TimeUnit unit) : 用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素；

